name: Build Windows EXE

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:  # Allows manual triggering
    inputs:
      version:
        description: 'Version tag (e.g., v1.0.0)'
        required: false
        type: string

permissions:
  contents: write  # Required to create releases and upload artifacts

jobs:
  build:
    runs-on: windows-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r build/requirements-build.txt
      
      - name: Diagnostic - Repository Structure
        run: |
          Write-Output "=== DIAGNOSTIC INFORMATION ==="
          Write-Output "Current directory: $PWD"
          Write-Output ""
          Write-Output "=== ROOT DIRECTORY CONTENTS ==="
          Get-ChildItem -Force | Format-Table Name, Mode, Length -AutoSize
          Write-Output ""
          Write-Output "=== CHECKING FOR BUILD DIRECTORY ==="
          if (Test-Path "build") {
            Write-Output "‚úì 'build' directory EXISTS"
            Write-Output "Contents of build/:"
            Get-ChildItem "build" | Format-Table Name, Mode, Length -AutoSize
          } else {
            Write-Output "‚úó 'build' directory NOT FOUND"
          }
          Write-Output ""
          Write-Output "=== CHECKING FOR BUILD.SPEC ==="
          $specPaths = @(
            "build\build.spec",
            "build\build.SPEC",
            "Build\build.spec",
            "BUILD\build.spec",
            ".\build\build.spec",
            "$PWD\build\build.spec"
          )
          foreach ($path in $specPaths) {
            if (Test-Path $path) {
              Write-Output "‚úì FOUND: $path"
              $fullPath = Resolve-Path $path
              Write-Output "  Full path: $fullPath"
            }
          }
          Write-Output ""
          Write-Output "=== SEARCHING FOR ALL .SPEC FILES ==="
          Get-ChildItem -Recurse -Filter "*.spec" -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Output "Found: $($_.FullName)"
          }
          Write-Output ""
          Write-Output "=== CHECKING FOR APP DIRECTORY ==="
          if (Test-Path "app") {
            Write-Output "‚úì 'app' directory EXISTS"
            Write-Output "Contents of app/:"
            Get-ChildItem "app" -Directory | Select-Object -First 10 Name
          } else {
            Write-Output "‚úó 'app' directory NOT FOUND"
          }
          Write-Output ""
          Write-Output "=== ALL TOP-LEVEL DIRECTORIES ==="
          Get-ChildItem -Directory | ForEach-Object {
            Write-Output "  - $($_.Name)"
          }
        shell: pwsh
      
      - name: Build EXE with PyInstaller
        run: |
          # Match the build.bat approach: change to app directory, then run pyinstaller
          Write-Output "Current directory: $PWD"
          
          # Find the spec file
          $specPath = $null
          if (Test-Path "build\build.spec") {
            $specPath = "build\build.spec"
          } elseif (Test-Path ".\build\build.spec") {
            $specPath = ".\build\build.spec"
          } else {
            # Search for it
            $found = Get-ChildItem -Recurse -Filter "build.spec" -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($found) {
              $specPath = $found.FullName
              Write-Output "Found spec file at: $specPath"
            } else {
              Write-Error "build.spec file not found anywhere!"
              exit 1
            }
          }
          
          Write-Output "Using spec file: $specPath"
          Write-Output "Changing to app directory..."
          Set-Location app
          Write-Output "Now in: $PWD"
          
          # Calculate relative path from app/ to spec file
          $relativeSpecPath = if ($specPath -like "build\*") { "..\$specPath" } else { $specPath }
          Write-Output "Running PyInstaller with: $relativeSpecPath"
          pyinstaller $relativeSpecPath --workpath=build --distpath=dist --clean
        shell: pwsh
      
      - name: Verify EXE exists
        run: |
          $exePath = "app\dist\MDI AutoLogin.exe"
          if (-not (Test-Path $exePath)) {
            Write-Error "Build failed: EXE not found at $exePath"
            exit 1
          }
          Write-Output "Build successful: EXE found at $exePath"
          
          # Get EXE file size
          $exeInfo = Get-Item $exePath
          Write-Output "EXE size: $([math]::Round($exeInfo.Length / 1MB, 2)) MB"
        shell: pwsh
      
      - name: Diagnostic - Analyze PyInstaller Build Output
        run: |
          Write-Output "=== PYINSTALLER BUILD ANALYSIS ==="
          Write-Output ""
          
          # Check for build warnings
          Write-Output "=== CHECKING BUILD LOG FOR WARNINGS ==="
          $buildLog = "app\build\MDI AutoLogin\warn-MDI AutoLogin.txt"
          if (Test-Path $buildLog) {
            Write-Output "Found build warnings log:"
            $warnings = Get-Content $buildLog -ErrorAction SilentlyContinue
            if ($warnings) {
              Write-Output $warnings
            } else {
              Write-Output "  No warnings found (good!)"
            }
          } else {
            Write-Output "  Warning log not found (this is normal for clean builds)"
          }
          Write-Output ""
          
          # Check for analysis file
          Write-Output "=== CHECKING FOR ANALYSIS FILE ==="
          $analysisFile = "app\build\MDI AutoLogin\Analysis-00.toc"
          if (Test-Path $analysisFile) {
            Write-Output "‚úì Analysis file found"
            Write-Output "  This file contains information about collected modules"
          } else {
            Write-Output "‚úó Analysis file not found"
          }
          Write-Output ""
          
          # Try to extract module information from build directory
          Write-Output "=== CHECKING COLLECTED MODULES ==="
          $buildDir = "app\build\MDI AutoLogin"
          if (Test-Path $buildDir) {
            $pyFiles = Get-ChildItem -Path $buildDir -Recurse -Filter "*.pyc" -ErrorAction SilentlyContinue | Select-Object -First 50
            Write-Output "Found $($pyFiles.Count) compiled Python files (showing first 50)"
            $pyFiles | ForEach-Object {
              $modulePath = $_.FullName.Replace($buildDir, "").Replace("\", ".").Replace(".pyc", "")
              Write-Output "  - $modulePath"
            }
          }
        shell: pwsh
        continue-on-error: true
      
      - name: Diagnostic - Check Critical Modules
        run: |
          Write-Output "=== CRITICAL MODULE VERIFICATION ==="
          Write-Output ""
          
          # List of critical modules that must be included
          $criticalModules = @(
            "unicodedata",
            "hmac",
            "http",
            "http.client",
            "urllib",
            "urllib.request",
            "urllib.parse",
            "certifi",
            "urllib3",
            "requests",
            "keyring",
            "jaraco.context",
            "jaraco.classes",
            "backports.tarfile",
            "psutil",
            "pystray",
            "PIL",
            "tkinter",
            "idna",
            "charset_normalizer"
          )
          
          # Check build directory for these modules
          $buildDir = "app\build\MDI AutoLogin"
          $missingModules = @()
          $foundModules = @()
          
          if (Test-Path $buildDir) {
            foreach ($module in $criticalModules) {
              $modulePath = $module.Replace(".", "\")
              $possiblePaths = @(
                "$buildDir\$modulePath.pyc",
                "$buildDir\$modulePath\__init__.pyc",
                "$buildDir\$modulePath.py"
              )
              
              $found = $false
              foreach ($path in $possiblePaths) {
                if (Test-Path $path) {
                  $found = $true
                  break
                }
              }
              
              # Also check for package directories
              if (-not $found) {
                $packageDir = "$buildDir\$modulePath"
                if (Test-Path $packageDir -PathType Container) {
                  $found = $true
                }
              }
              
              if ($found) {
                $foundModules += $module
                Write-Output "‚úì $module"
              } else {
                $missingModules += $module
                Write-Output "‚úó $module (NOT FOUND)"
              }
            }
          } else {
            Write-Output "‚ö† Build directory not found - cannot verify modules"
          }
          
          Write-Output ""
          Write-Output "=== SUMMARY ==="
          Write-Output "Found: $($foundModules.Count) / $($criticalModules.Count) critical modules"
          if ($missingModules.Count -gt 0) {
            Write-Output "‚ö† WARNING: Missing modules:"
            $missingModules | ForEach-Object { Write-Output "  - $_" }
            Write-Output ""
            Write-Output "These modules may cause runtime errors!"
          } else {
            Write-Output "‚úì All critical modules appear to be included"
          }
        shell: pwsh
        continue-on-error: true
      
      - name: Diagnostic - Check Data Files
        run: |
          Write-Output "=== DATA FILES VERIFICATION ==="
          Write-Output ""
          
          $buildDir = "app\build\MDI AutoLogin"
          $dataDirs = @("tcl", "tk", "certifi")
          
          foreach ($dataDir in $dataDirs) {
            $dataPath = "$buildDir\$dataDir"
            if (Test-Path $dataPath) {
              $fileCount = (Get-ChildItem -Path $dataPath -Recurse -File -ErrorAction SilentlyContinue).Count
              Write-Output "‚úì $dataDir (found, $fileCount files)"
            } else {
              Write-Output "‚úó $dataDir (NOT FOUND)"
            }
          }
          
          # Check for certifi certificates
          Write-Output ""
          Write-Output "=== CERTIFI CERTIFICATES ==="
          $certPaths = @(
            "$buildDir\certifi\cacert.pem",
            "$buildDir\certifi\__pycache__\cacert.cpython*.pyc"
          )
          $certFound = $false
          foreach ($certPath in $certPaths) {
            if (Test-Path $certPath) {
              Write-Output "‚úì Certificates found: $certPath"
              $certFound = $true
              break
            }
          }
          if (-not $certFound) {
            # Try to find any cert file
            $anyCert = Get-ChildItem -Path $buildDir -Recurse -Filter "*cert*" -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($anyCert) {
              Write-Output "‚ö† Found certificate-related file: $($anyCert.FullName)"
            } else {
              Write-Output "‚úó No certificate files found (may cause SSL errors)"
            }
          }
        shell: pwsh
        continue-on-error: true
      
      - name: Diagnostic - Generate Module Report
        run: |
          Write-Output "=== GENERATING MODULE REPORT ==="
          Write-Output ""
          
          $buildDir = "app\build\MDI AutoLogin"
          $reportFile = "module_report.txt"
          
          if (Test-Path $buildDir) {
            # Collect all Python modules
            $allModules = @()
            $pyFiles = Get-ChildItem -Path $buildDir -Recurse -Filter "*.pyc" -ErrorAction SilentlyContinue
            $pySourceFiles = Get-ChildItem -Path $buildDir -Recurse -Filter "*.py" -ErrorAction SilentlyContinue
            
            foreach ($file in ($pyFiles + $pySourceFiles)) {
              $relativePath = $file.FullName.Replace($buildDir, "").TrimStart("\")
              $modulePath = $relativePath.Replace("\", ".").Replace(".pyc", "").Replace(".py", "")
              if ($modulePath -and -not $allModules.Contains($modulePath)) {
                $allModules += $modulePath
              }
            }
            
            # Also check for package directories
            $packageDirs = Get-ChildItem -Path $buildDir -Directory -Recurse -ErrorAction SilentlyContinue
            foreach ($dir in $packageDirs) {
              $relativePath = $dir.FullName.Replace($buildDir, "").TrimStart("\")
              $modulePath = $relativePath.Replace("\", ".")
              if ($modulePath -and -not $allModules.Contains($modulePath)) {
                $allModules += $modulePath
              }
            }
            
            # Sort and write report
            $allModules = $allModules | Sort-Object
            
            @"
=== MODULE INCLUSION REPORT ===
Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
Total modules found: $($allModules.Count)

=== ALL COLLECTED MODULES ===
$($allModules -join "`n")

=== KEY PACKAGES ===
$(if ($allModules -match "certifi") { "‚úì certifi" } else { "‚úó certifi" })
$(if ($allModules -match "urllib3") { "‚úì urllib3" } else { "‚úó urllib3" })
$(if ($allModules -match "requests") { "‚úì requests" } else { "‚úó requests" })
$(if ($allModules -match "keyring") { "‚úì keyring" } else { "‚úó keyring" })
$(if ($allModules -match "jaraco") { "‚úì jaraco.*" } else { "‚úó jaraco.*" })
$(if ($allModules -match "backports") { "‚úì backports.*" } else { "‚úó backports.*" })
$(if ($allModules -match "psutil") { "‚úì psutil" } else { "‚úó psutil" })
$(if ($allModules -match "pystray") { "‚úì pystray" } else { "‚úó pystray" })
$(if ($allModules -match "PIL|Pillow") { "‚úì PIL/Pillow" } else { "‚úó PIL/Pillow" })
$(if ($allModules -match "tkinter") { "‚úì tkinter" } else { "‚úó tkinter" })
$(if ($allModules -match "http") { "‚úì http.*" } else { "‚úó http.*" })
$(if ($allModules -match "unicodedata") { "‚úì unicodedata" } else { "‚úó unicodedata" })
$(if ($allModules -match "hmac") { "‚úì hmac" } else { "‚úó hmac" })
"@ | Out-File -FilePath $reportFile -Encoding UTF8
            
            Write-Output "Report saved to: $reportFile"
            Write-Output "Total modules: $($allModules.Count)"
            
            # Upload as artifact
            Write-Output "::notice::Module report generated with $($allModules.Count) modules"
          } else {
            Write-Output "‚ö† Build directory not found - cannot generate report"
          }
        shell: pwsh
        continue-on-error: true
      
      - name: Upload Module Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: build-diagnostics
          path: |
            module_report.txt
            app/build/**/warn-*.txt
          retention-days: 7
      
      - name: Diagnostic - Build Summary
        run: |
          Write-Output "=== BUILD DIAGNOSTIC SUMMARY ==="
          Write-Output ""
          
          $exePath = "app\dist\MDI AutoLogin.exe"
          $buildDir = "app\build\MDI AutoLogin"
          
          # Check EXE
          if (Test-Path $exePath) {
            $exeInfo = Get-Item $exePath
            $sizeMB = [math]::Round($exeInfo.Length / 1MB, 2)
            Write-Output "‚úì EXE built successfully"
            Write-Output "  Size: $sizeMB MB"
            Write-Output "  Path: $exePath"
            Write-Output "::notice title=Build Success::EXE built successfully ($sizeMB MB)"
          } else {
            Write-Output "‚úó EXE not found"
            Write-Output "::error title=Build Failed::EXE not found at $exePath"
          }
          Write-Output ""
          
          # Check critical modules
          $criticalModules = @("certifi", "urllib3", "requests", "keyring", "http", "unicodedata", "hmac", "backports.tarfile", "jaraco.context")
          $foundCount = 0
          $missingCount = 0
          
          if (Test-Path $buildDir) {
            foreach ($module in $criticalModules) {
              $modulePath = $module.Replace(".", "\")
              $found = (Test-Path "$buildDir\$modulePath") -or 
                       (Test-Path "$buildDir\$modulePath.pyc") -or 
                       (Test-Path "$buildDir\$modulePath\__init__.pyc") -or
                       (Get-ChildItem -Path $buildDir -Recurse -Filter "*$module*" -ErrorAction SilentlyContinue | Select-Object -First 1)
              
              if ($found) {
                $foundCount++
              } else {
                $missingCount++
                Write-Output "::warning title=Missing Module::Module '$module' not found in build"
              }
            }
            
            Write-Output "Module check: $foundCount found, $missingCount missing"
            if ($missingCount -eq 0) {
              Write-Output "::notice title=Module Check::All critical modules included"
            } else {
              Write-Output "::warning title=Module Check::$missingCount critical modules may be missing"
            }
          }
          Write-Output ""
          
          # Check data files
          $dataFiles = @("tcl", "tk", "certifi")
          $dataFound = 0
          foreach ($data in $dataFiles) {
            if (Test-Path "$buildDir\$data") {
              $dataFound++
            }
          }
          Write-Output "Data files: $dataFound / $($dataFiles.Count) found"
          Write-Output ""
          
          # Final status
          if ((Test-Path $exePath) -and $missingCount -eq 0) {
            Write-Output "‚úì BUILD STATUS: SUCCESS"
            Write-Output "  All checks passed"
          } elseif (Test-Path $exePath) {
            Write-Output "‚ö† BUILD STATUS: WARNING"
            Write-Output "  EXE built but some modules may be missing"
          } else {
            Write-Output "‚úó BUILD STATUS: FAILED"
            Write-Output "  EXE not found"
          }
        shell: pwsh
        continue-on-error: true
      
      - name: Get version from tag or input
        id: get_version
        shell: pwsh
        run: |
          $ref = "${{ github.ref }}"
          $eventName = "${{ github.event_name }}"
          
          if ($ref -match '^refs/tags/(.+)$') {
            $version = $matches[1]
            Write-Output "Using tag version: $version"
          } elseif ($eventName -eq "workflow_dispatch") {
            $inputVersion = "${{ github.event.inputs.version }}"
            if ($inputVersion) {
              $version = $inputVersion
            } else {
              $version = "v$(Get-Date -Format 'yyyy.MM.dd')"
            }
            Write-Output "Using input/date version: $version"
          } else {
            $version = "v$(Get-Date -Format 'yyyy.MM.dd')"
            Write-Output "Using date version: $version"
          }
          Write-Output "version=$version" >> $env:GITHUB_OUTPUT
      
      - name: Rename EXE with version
        shell: pwsh
        run: |
          $version = "${{ steps.get_version.outputs.version }}"
          $exePath = "app\dist\MDI AutoLogin.exe"
          $newName = "MDI_AutoLogin-$version.exe"
          Rename-Item -Path $exePath -NewName $newName
          Write-Output "Renamed to: $newName"
      
      - name: Upload EXE artifact
        uses: actions/upload-artifact@v4
        with:
          name: MDI_AutoLogin-${{ steps.get_version.outputs.version }}
          path: app/dist/MDI_AutoLogin-*.exe
          retention-days: 30
      
      - name: Create Release (if tag)
        if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v1
        with:
          files: app/dist/MDI_AutoLogin-*.exe
          draft: false
          prerelease: false
          generate_release_notes: true
          tag_name: ${{ steps.get_version.outputs.version }}
          name: Release ${{ steps.get_version.outputs.version }}
          body: |
            ## MDI AutoLogin ${{ steps.get_version.outputs.version }}
            
            ### üì¶ What's Included
            - Standalone Windows executable (no Python required)
            - Automatic Wi-Fi login for MDI network
            - System tray integration
            - Secure credential storage
            
            ### üöÄ Installation
            1. Download `MDI_AutoLogin-${{ steps.get_version.outputs.version }}.exe`
            2. Run the executable
            3. Configure your credentials in Settings
            4. Enable "Start with Windows" for automatic login
            
            ### üìù Notes
            - Credentials are stored securely in Windows Credential Manager
            - First run will prompt you to configure settings
            - The app runs in the system tray (look for the icon)
            
            ### ‚ö†Ô∏è Important
            - When closing the app, you may see a harmless "Failed to remove temporary directory" warning. This is a known PyInstaller behavior and doesn't affect functionality.
            
            ### üîó Links
            - [Full Documentation](https://github.com/pawasagrwl/MDI_AutoLogin#readme)
            - [Report Issues](https://github.com/pawasagrwl/MDI_AutoLogin/issues)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

